import { scaleBand, scaleLinear } from "d3-scale";
import { select as d3Select } from "d3-selection";
import "./../style/visual.less";

import { axisBottom } from "d3-axis";

import powerbi from "powerbi-visuals-api";
import "regenerator-runtime/runtime";

import DataViewCategoryColumn = powerbi.DataViewCategoryColumn;
import DataViewObjects = powerbi.DataViewObjects;
import Fill = powerbi.Fill;
import ISandboxExtendedColorPalette = powerbi.extensibility.ISandboxExtendedColorPalette;
import ISelectionId = powerbi.visuals.ISelectionId;
import IVisual = powerbi.extensibility.IVisual;
import IVisualHost = powerbi.extensibility.visual.IVisualHost;
import PrimitiveValue = powerbi.PrimitiveValue;
import VisualUpdateOptions = powerbi.extensibility.visual.VisualUpdateOptions;
import VisualConstructorOptions = powerbi.extensibility.visual.VisualConstructorOptions;

import { textMeasurementService } from "powerbi-visuals-utils-formattingutils";
import { FormattingSettingsService } from "powerbi-visuals-utils-formattingmodel";

import { BarChartSettingsModel } from "./barChartSettingsModel";
import { getCategoricalObjectValue, getValue } from "./objectEnumerationUtility";

type Selection<T1, T2 = T1> = d3.Selection<any, T1, any, T2>;

export interface BarChartDataPoint {
  value: PrimitiveValue;
  category: string;
  color: string;
  strokeColor: string;
  strokeWidth: number;
  selectionId: ISelectionId;
}

function createSelectorDataPoints(
  options: VisualUpdateOptions,
  host: IVisualHost
): BarChartDataPoint[] {
  let barChartDataPoints: BarChartDataPoint[] = [];
  let dataViews = options.dataViews;

  if (
    !dataViews ||
    !dataViews[0] ||
    !dataViews[0].categorical ||
    !dataViews[0].categorical.categories ||
    !dataViews[0].categorical.categories[0].source ||
    !dataViews[0].categorical.values
  ) {
    return barChartDataPoints;
  }

  let categorical = dataViews[0].categorical;
  let category = categorical.categories[0];
  let dataValue = categorical.values[0];

  let colorPalette: ISandboxExtendedColorPalette = host.colorPalette;

  const strokeColor: string = getColumnStrokeColor(colorPalette);

  const strokeWidth: number = getColumnStrokeWidth(colorPalette.isHighContrast);

  for (let i = 0, len = Math.max(category.values.length, dataValue.values.length); i < len; i++) {
    const color: string = getColumnColorByIndex(category, i, colorPalette);

    const selectionId: ISelectionId = host
      .createSelectionIdBuilder()
      .withCategory(category, i)
      .createSelectionId();

    barChartDataPoints.push({
      color,
      strokeColor,
      strokeWidth,
      selectionId,
      value: dataValue.values[i],
      category: `${category.values[i]}`,
    });
  }

  return barChartDataPoints;
}

function getColumnColorByIndex(
  category: DataViewCategoryColumn,
  index: number,
  colorPalette: ISandboxExtendedColorPalette
): string {
  if (colorPalette.isHighContrast) {
    return colorPalette.background.value;
  }

  const defaultColor: Fill = {
    solid: {
      color: colorPalette.getColor(`${category.values[index]}`).value,
    },
  };

  return getCategoricalObjectValue<Fill>(category, index, "colorSelector", "fill", defaultColor)
    .solid.color;
}

function getColumnStrokeColor(colorPalette: ISandboxExtendedColorPalette): string {
  return colorPalette.isHighContrast ? colorPalette.foreground.value : null;
}

function getColumnStrokeWidth(isHighContrast: boolean): number {
  return isHighContrast ? 2 : 0;
}

function getAxisTextFillColor(
  objects: DataViewObjects,
  colorPalette: ISandboxExtendedColorPalette,
  defaultColor: string
): string {
  if (colorPalette.isHighContrast) {
    return colorPalette.foreground.value;
  }

  return getValue<Fill>(objects, "enableAxis", "fill", {
    solid: {
      color: defaultColor,
    },
  }).solid.color;
}

export class BarChart implements IVisual {
  private svg: Selection<any>;
  private host: IVisualHost;
  private barContainer: Selection<SVGElement>;
  private xAxis: Selection<SVGElement>;
  private barDataPoints: BarChartDataPoint[];
  private formattingSettings: BarChartSettingsModel;
  private formattingSettingsService: FormattingSettingsService;

  private barSelection: d3.Selection<d3.BaseType, any, d3.BaseType, any>;

  static Config = {
    xScalePadding: 0.1,
    solidOpacity: 1,
    transparentOpacity: 1,
    margins: {
      top: 0,
      right: 0,
      bottom: 25,
      left: 30,
    },
    xAxisFontMultiplier: 0.04,
  };

  /**
   * Creates instance of BarChart. This method is only called once.
   *
   * @constructor
   * @param {VisualConstructorOptions} options - Contains references to the element that will
   *                                             contain the visual and a reference to the host
   *                                             which contains services.
   */
  constructor(options: VisualConstructorOptions) {
    this.host = options.host;
    const localizationManager = this.host.createLocalizationManager();
    this.formattingSettingsService = new FormattingSettingsService(localizationManager);
    console.log("options.viewMode", options);
    this.svg = d3Select(options.element).append("svg").classed("barChart", true);

    this.barContainer = this.svg.append("g").classed("barContainer", true);

    this.xAxis = this.svg.append("g").classed("xAxis", true);
  }

  public update(options: VisualUpdateOptions) {
    console.log("OKKKKKKKKKK 1");
    this.formattingSettings = this.formattingSettingsService.populateFormattingSettingsModel(
      BarChartSettingsModel,
      options.dataViews
    );
    this.barDataPoints = createSelectorDataPoints(options, this.host);
    this.formattingSettings.populateColorSelector(this.barDataPoints);

    let width = options.viewport.width;
    let height = options.viewport.height;

    this.svg.attr("width", width).attr("height", height);

    if (this.formattingSettings.enableAxis.show.value) {
      let margins = BarChart.Config.margins;
      height -= margins.bottom;
    }

    this.xAxis
      .style("font-size", Math.min(height, width) * BarChart.Config.xAxisFontMultiplier)
      .style("fill", this.formattingSettings.enableAxis.fill.value.value);

    let yScale = scaleLinear()
      .domain([0, <number>options.dataViews[0].categorical.values[0].maxLocal])
      .range([height, 0]);

    let xScale = scaleBand()
      .domain(this.barDataPoints.map((d) => d.category))
      .rangeRound([0, width])
      .padding(0.2);

    let xAxis = axisBottom(xScale);

    const colorObjects = options.dataViews[0] ? options.dataViews[0].metadata.objects : null;
    this.xAxis
      .attr("transform", "translate(0, " + height + ")")
      .call(xAxis)
      .attr(
        "color",
        getAxisTextFillColor(
          colorObjects,
          this.host.colorPalette,
          this.formattingSettings.enableAxis.fill.value.value
        )
      );

    const textNodes = this.xAxis.selectAll("text");
    BarChart.wordBreak(textNodes, xScale.bandwidth(), height);

    this.barSelection = this.barContainer.selectAll(".bar").data(this.barDataPoints);

    const barSelectionMerged = this.barSelection
      .enter()
      .append("rect")
      .merge(<any>this.barSelection);

    barSelectionMerged.classed("bar", true);

    barSelectionMerged
      .attr("width", xScale.bandwidth())
      .attr("height", (d) => height - yScale(<number>d.value))
      .attr("y", (d) => yScale(<number>d.value))
      .attr("x", (d) => xScale(d.category))
      .style("fill", (dataPoint: BarChartDataPoint) => dataPoint.color)
      .style("stroke", (dataPoint: BarChartDataPoint) => dataPoint.strokeColor)
      .style("stroke-width", (dataPoint: BarChartDataPoint) => `${dataPoint.strokeWidth}px`);

    this.barSelection.exit().remove();
  }

  private static wordBreak(
    textNodes: Selection<any, SVGElement>,
    allowedWidth: number,
    maxHeight: number
  ) {
    textNodes.each(function () {
      textMeasurementService.wordBreak(this, allowedWidth, maxHeight);
    });
  }

  public getFormattingModel(): powerbi.visuals.FormattingModel {
    return this.formattingSettingsService.buildFormattingModel(this.formattingSettings);
  }
}
